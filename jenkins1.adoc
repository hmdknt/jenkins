= タイトル
Jenkinsの紹介

== 時間
.表
[cols="40,20,20,20",options="header"]

|===
| 項目 | 話す内容 | 図 | 時間
| 前提 | ○ | なし | 1m
| CIって何？ | ○ | ○ | 2～3m
| CIのメリット | ○ | 使わない予定であったが使うかも | 3m
| CIで利用できるツールって何があるの？ | a | ○ | 1～2m
| Jenkins | ○ | なし | 1m
| Jenkinの起動方法 | a | a | a
| Jenkinsのメリットって？ | a | a | a
| Git(タイトル考える) | a | a | a
| Jenkins2 | a | a | a
| プロジェクトの構成 | a | なし | 1～2m
| ビルドパイプラインの紹介 | a | ○ | 2m

|===

=== 前提
今回、Jenkinsについて紹介を行いたいと思いますが、現在のプロジェクトがJavaの開発を行っていることや +
JenkinsがJavaの開発で広く利用されていることから、今回はJavaの開発を前提としてJenkinsについて +
説明をさせていだだきます。 +
もちろんJenkinsはJavaだけでなく、Python、PHPといったJava以外の開発でも利用することができますが、 +
今回は説明を省かせていただきます。


=== CIって何？
Jenkinsについて説明をするまえにCIについて知っていただく必要があるため、まずはCIについて説明を行います。 +
皆さん、CIって何かご存知でしょうか？ +
CIとはContinuouts Integrationの略で、一般的には継続的インテグレーションと呼ばれています。 +
具体的には、開発者がGitやSVNなどのバージョン管理システムに対してソースコードの変更をコミットする度に、 +
スライドで示すようなビルドを自動的に行うことを指します。 +

image:reveal.js/images/build.png[]

ここでいうデプロイとは、静的解析の結果をSonarQubeのようなメトリクスツールに送信することや +
Nexusやartifactoryといったライブラリ管理ツールにアーティファクトを登録することを言います。 +


==== CIのメリット
CIのメリットとして、次のようなことが挙げられます。

* 機械的にビルドを実行するため、ビルドの工程をすべて網羅することが可能となり、開発者がローカル環境で見逃したコーディング規約違反やテストケース漏れを防ぐことができます
* 自動でビルドが実行されるため、稼働時間の短縮につながります
* ビルドが失敗した場合、基本的にはビルドが成功するまで修正を繰り返すため、ミスの混入が少なくなり、工程が進んだ後の手戻りのリスクを削減することができます
* 人間による作業ミスが減るため、品質の維持につながります


=== CIで利用できるツールって何があるの？
先ほど説明したようなビルドを自動で実行するためのツールはいくつかありますが、ここではJenkins、CircleCI、TravisCIについて +
簡単に説明したいと思います。

この3つのCIツールをの面で比較すると、Jenkinsはオンプレミスであり、残りのCircleCiとTravisCiはSaasです。 +
次に、GitHubと連携ができるかを比較した時に、3つのツールともGithubと連携することが可能です。 +
次に、WebGUIの設定ができるかを比較したときに、JenkinsとCircleCIはWebGUIによる設定することが可能ですが、 +
TravisCiに関しては、yaml定義ファイルによって設定を行う必要があります。

=== Jenkins
JenkinsとはCIで説明したビルドを自動で行うためのツールである。

==== Jenkinの起動方法
ここでは、Jenkinsを利用するための前準備は完了している前提で起動方法について説明を行います。

jenkinsのホームページからjenkins.warをダウンロードします。java -jar jenkins.warで起動可能です。 +
あとは、http://localhost:8080にアクセスすればJenkinsを利用することができます。

また、tomcatのwebappsディレクトリにjenkins.warを配置し、tomcatを起動することでもJenkinsを利用することが可能です。

docker

==== Jenkinsのメリットって？
Jenkinsを利用するメリットはいくつかあります。 +

** 集合知がある +
Jenkinsには多くのプラグインが存在し、用途によって使用するプラグインを選択し自由にカスタマイズできるため汎用性が高いです。 +
また、書籍も出版されておりネットにも多くの情報が転がっているため、設定方法やエラー事象の解決方法を発見できる可能性が高いです。

** GUIで設定可能 +
Jenkinsのタスクを実行するための設定(ジョブ)はGUIベースで行うことができ、誰でも簡単に設定することができます。 +
項目についての説明は省かせていただきますが、基本的には、設定したいものにチェックを入れ、チェックを入れると出てくる項目に設定内容を +
追加することでその処理が適応されます。　+
image:reveal.js/images/settings1.png[]
image:reveal.js/images/settings2.png[]

** 定期実行可能 +
JenkinsはCronによってビルドの実行時間を設定することができます。これにより、毎日定期的に行うビルドに関しては、人の手で行う必要がなくなる +
ため、ビルド忘れの防止や稼働時間の削減につながります。
image:reveal.js/images/execute_time.png[]

** WebHookの設定が可能
WebHookとは、簡単に説明するとAというWEBサービスとBというWEBサービスがあったときに、WebHookを設定していると、AのWebサービスでイベントが +
発生したとき、BのWebサービスにイベントが発生したしたことを通知するようなことを言います。Jenkinsを例に挙げると、ソースコード管理システムに +
対して変更を加えたとき、JenkinsがGitから受けたイベント内容によって処理を設定することができます。

=== Git

先ほどGitについて少し話をしたので、急ではありますがここでGitについて説明したいと思います。 +
皆さん、そもそもGitを利用していますか？ +
まだ、バージョン管理システムにSVNを利用していませんか？バージョン管理システムと言えば今はGitです。 +
image:reveal.js/images/statics.png[]

参考資料：https://blogs.oracle.com/ouchina/2016java

ZeroTurnaround社が2016年に公表した資料の中のバージョン管理システムの利用率を示したグラフをご覧ください。 +
2016年時点のGitの利用率は68%と全体の3分の2を占めており、バージョン管理システムにSVNではなくGitが広く +
使われていることが分かると思います。　+

なぜ、ソースコード管理システムにGitが多く使われているのでしょうか？ +









SVNは基本的に、trunk、tag、branchの3つで構成されており、基本的には全員がトランクで作業を行い、ある作業時点のトランクの状態をタグを打ち判断できるようにし +
別の開発を行うときは、branchを切るといった流れです。開発者が作業する場所がtrunkしかないうえに、リポジトリが一つであり、変更を容易にコミットすることが +
できなかった。また、レビューをする際には管理簿のようなものを用意する必要があった。 +
Gitは、masterとブランチから構成されており、開発者はmasterからブランチを複数切ることができ、ブランチごとに作業を分けることが可能となりました。また、リモートと +
ローカルにリポジトリを持っており、変更をSVNとはことなり容易にコミットできるようになりました。
最も大きな点としてはソースコード差分を見ることができ、それに対してレビューが行えるため、Gitだけで変更の管理を行えるようになりました。

=== Jenkins2

ここまでに説明したメリットはJenkins1の情報であり、ご存知の方も多いのではないでしょうか？ +
Jenkins2では、大きく変わった点があります。

** Jenkinsfileが追加された
pipeline機能がJenkins1では、プラグインを利用する必要があったが、Jenknis2からは公式サポートされたことにより +
Jenkinsfileが追加された。


Gitとの相性が良くなったというのはgitの機能に関連します。

multibranchPipelineではブランチごとにジョブが実行され、Pipelineでは指定したブランチのみジョブが実行されます。 +

** ジョブの定義をファイルで行うことが可能となった +
Jenkins1を利用したことがある人はブランチがたくさんできるからその度にジョブを定義しなくてはいけないのではと思ったのではないでしょうか？ +
これを解決するのがJenkins2から導入されたJenkinsfileです。 +
Jenkinsfileはgroovyで書けるジョブを定義したファイルです。 +
このJenkinsfileをmasterに持たせておけば、ブランチを切る度にそのブランチにはJenkinsfileが存在するため、 +
わざわざブランチごとにジョブを作成する必要がなくなります。 +
また、ファイルでジョブ設定を管理できることになったことによって、バックアップをGUIで設定を変更の度に取らなくても良くなり、 +
バックアップができていなかった時にも、柔軟に対応することが可能となります。 +
また、ファイル管理できることで、複数の人が設定を変更することが可能になり、またgitで管理をしているためコードの差分に対してレビューができるようになります。 +
デメリットとしては、ファイルを書けないと設定ができないため属人性が生まれてしまう可能性があるということです。 +
