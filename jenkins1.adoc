= タイトル
Jenkinsの紹介

== 時間
.表
[cols="40,20,20,20",options="header"]

|===
| 項目 | 話す内容 | 図 | 時間
| 前提 | ○ | なし | 1m
| CIって何？ | ○ | ○ | 2~3m
| CIのメリット | ○ | 使わない予定であったが使うかも | 3m
| CIで利用できるツールって何があるの？ | a | a | a
| Jenkins | ○ | なし | 1m
| Jenkinの起動方法 | a | a | a
| CIで利用できるツールって何があるの？ | a | a | a
| Jenkinsのメリットって？ | a | a | a
| Git(タイトル考える) | a | a | a
| Jenkins2 | a | a | a
| プロジェクトの構成 | a | なし | a
| ビルドパイプラインの紹介 | a | △ | a

|===

=== 前提
今回、Jenkinsについて紹介を行いたいと思いますが、現在のプロジェクトがJavaの開発を行っていることや +
JenkinsがJavaの開発で広く利用されていることから、今回はJavaの開発を前提としてJenkinsについて +
説明をさせていだだきます。 +
もちろんJenkinsはJavaだけでなく、Python、PHPといったJava以外の開発でも利用することができますが、 +
今回は説明を省かせていただきます。


=== CIって何？
Jenkinsについて説明をするまえにCIについて知っていただく必要があるため、まずはCIについて説明を行います。 +
皆さん、CIって何かご存知でしょうか？ +
CIとはContinuouts Integrationの略で、一般的には継続的インテグレーションと呼ばれています。 +
具体的には、開発者がGitやSVNなどのバージョン管理システムに対してソースコードの変更をコミットする度に、 +
スライドで示すようなビルドを自動的に行うことを指します。 +

image:reveal.js/images/build.png[]

ここでいうデプロイとは、静的解析の結果をSonarQubeのようなメトリクスツールに登録することや +
Nexusやartifactoryといったライブラリ管理ツールにアーティファクトを登録することを言います。 +


==== CIのメリット
CIのメリットとして、次のようなことが挙げられます。

* 機械的にビルドを実行するため、ビルドの工程をすべて網羅することが可能となり、開発者がローカル環境で見逃したコーディング規約違反やテストケース漏れを防ぐことができます
* 自動でビルドが実行されるため、稼働時間の短縮につながります
* ビルドが失敗した場合、基本的にはビルドが成功するまで修正を繰り返すため、ミスの混入が少なくなり、工程が進んだ後の手戻りのリスクを削減することができます
* 人間による作業ミスが減るため、品質の維持につながります


=== CIで利用できるツールって何があるの？
先ほど説明したようなビルドを自動で実行するためのツールはいくつかありますが、ここではJenkins、CircleCI、TravisCIについて +
簡単に説明したいと思います。

この3つのCIツールをの面で比較すると、Jenkinsはオンプレミスであり、残りのCircleCiとTravisCiはSaasです。 +
次に、GitHubと連携ができるかを比較した時に、3つのツールともGithubと連携することが可能です。 +
次に、WebGUIの設定ができるかを比較したときに、JenkinsとCircleCIはWebGUIによる設定することが可能ですが、 +
TravisCiに関しては、yaml定義ファイルによって設定を行う必要があります。

=== Jenkins
JenkinsとはCIで説明したビルドを自動で行うためのツールである。

==== Jenkinの構築方法
* jre環境があれば、java -jar jenkins.warで起動可能です
* tomcatにjenkins.war  +
いかに簡単に起動できるかを示すため、起動を図を使って説明する。 +
* docker run


==== Jenkinsのメリットって？
Jenkinsを利用するメリットはいくつかあります。 +

** 集合知がある +
Jenkinsには多くのプラグインが存在し、用途によって使用するプラグインを選択し自由にカスタマイズできるため汎用性が高いです。 +
また、書籍も出版されておりネットにも多くの情報が転がっているため、設定方法やエラー事象の解決方法を発見できる可能性が高いです。

** GUIで設定可能 +
Jenkinsのタスクを実行するための設定(ジョブ)はGUIベースで行うことができ、誰でも簡単に設定することができる。 +

** 定期実行可能 +
ビルドを行う時間を設定することが可能であるため、毎日行うビルドがあった場合、ビルド忘れをなくすことができ作業の手間を省くことにもつながります。 +
以下のように
image:reveal.js/images/execute_time.png[]

** WebHookの設定が可能
WebHookとは、簡単に説明すると、


=== Git

話がそれますがここでGitについて説明をします。急にJenkinsではなくGitについて話が変わりますが、のちのちの説明でなぜGitについて +
触れたかがわかると思います。 +
皆さん、そもそもGitを利用していますか？ +
まだ、バージョン管理システムにSVNを利用していませんか？ +
SVNはもう時代遅れです。 +

以上のグラフからも分かるように、ソースコード管理といえば今はgitです。


Gitの何が良いのかについて説明します。 +
Gitとは、SVNと同じソースコード管理システムの1つです。 +
ここで図を使う(SVNとGitの比較) +
SVNは基本的に、trunk、tag、branchの3つで構成されており、基本的には全員がトランクで作業を行い、ある作業時点のトランクの状態をタグを打ち判断できるようにし +
別の開発を行うときは、branchを切るといった流れです。開発者が作業する場所がtrunkしかないうえに、リポジトリが一つであり、変更を容易にコミットすることが +
できなかった。また、レビューをする際には管理簿のようなものを用意する必要があった。 +
Gitは、masterとブランチから構成されており、開発者はmasterからブランチを複数切ることができ、ブランチごとに作業を分けることが可能となりました。また、リモートと +
ローカルにリポジトリを持っており、変更をSVNとはことなり容易にコミットできるようになりました。
最も大きな点としてはソースコード差分を見ることができ、それに対してレビューが行えるため、Gitだけで変更の管理を行えるようになりました。

SVNとGitの比較に関しては、もう少し調べる必要あり。

=== Jenkins2

ここまでに説明したメリットはJenkins1の情報であり、ご存知の方も多いのではないでしょうか？ +
Jenkins2では、大きく変わった点があります。

** Jenkinsfileが追加された
pipeline機能がJenkins1では、プラグインを利用する必要があったが、Jenknis2からは公式サポートされたことにより +
Jenkinsfileが追加された。


Gitとの相性が良くなったというのはgitの機能に関連します。

multibranchPipelineではブランチごとにジョブが実行され、Pipelineでは指定したブランチのみジョブが実行されます。 +

** ジョブの定義をファイルで行うことが可能となった +
Jenkins1を利用したことがある人はブランチがたくさんできるからその度にジョブを定義しなくてはいけないのではと思ったのではないでしょうか？ +
これを解決するのがJenkins2から導入されたJenkinsfileです。 +
Jenkinsfileはgroovyで書けるジョブを定義したファイルです。 +
このJenkinsfileをmasterに持たせておけば、ブランチを切る度にそのブランチにはJenkinsfileが存在するため、 +
わざわざブランチごとにジョブを作成する必要がなくなります。 +
また、ファイルでジョブ設定を管理できることになったことによって、バックアップをGUIで設定を変更の度に取らなくても良くなり、 +
バックアップができていなかった時にも、柔軟に対応することが可能となります。 +
また、ファイル管理できることで、複数の人が設定を変更することが可能になり、またgitで管理をしているためコードの差分に対してレビューができるようになります。 +
デメリットとしては、ファイルを書けないと設定ができないため属人性が生まれてしまう可能性があるということです。 +





