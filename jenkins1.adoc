= タイトル
Jenkinsの紹介



== 時間
.表
[cols="40,20,20,20",options="header"]

|===
| 項目 | 話す内容 | 図 | 時間
| 前提 | ○ | なし | 1m
| CIって何？ | ○ | ○ | 2～3m
| CIのメリット | ○ | ○ | 3m
| CIで利用できるツールって何があるの？ | ○ | ○ | 1～2m
| Jenkins | ○ | なし | 1m
| Jenkinの起動方法 | a | a | 1～2m
| Jenkinsのメリットって？ | ○ | ○ | 3m
| Git(タイトル考える) | a | a | a
| Jenkins2 | a | a | 5m
| プロジェクトの構成 | a | なし | 1～2m
| ビルドパイプラインの紹介 | a | ○ | 2m

|===



=== 前提
今回、Jenkinsについて紹介を行いたいと思いますが、現在のプロジェクトがJavaの開発を行っていることや +
JenkinsがJavaの開発で広く利用されていることから、今回はJavaの開発を前提としてJenkinsについて +
説明をさせていだだきます。 +
もちろんJenkinsはJavaだけでなく、Python、PHPといったJava以外の開発でも利用することができますが、 +
今回は説明を省かせていただきます。



=== CIって何？
Jenkinsについて説明をするまえにCIについて知っていただく必要があるため、まずはCIについて説明を行います。 +
皆さん、CIって何かご存知でしょうか？ +
CIとはContinuouts Integrationの略で、一般的には継続的インテグレーションと呼ばれています。 +
具体的には、開発者がGitやSVNなどのバージョン管理システムに対してソースコードの変更をコミットする度に、 +
スライドで示すようなビルドを自動的に行うことを指します。 +

image:reveal.js/images/build.png[]

ここでいうデプロイとは、静的解析の結果をSonarQubeのようなメトリクスツールに送信することや +
Nexusやartifactoryといったライブラリ管理ツールにアーティファクトを登録することを言います。 +



==== CIのメリット
CIのメリットとして、次のようなことが挙げられます。

* 機械的にビルドを実行するため、ビルドの工程をすべて網羅することが可能となり、開発者がローカル環境で見逃したコーディング +
規約違反やテストケース漏れを防ぐことができます
* 自動でビルドが実行されるため、稼働時間の短縮につながります
* バージョン管理システムに変更が適応される度にビルドを行い、ビルドが失敗したらビルドが成功するまで修正を繰り返すという +
  サイクルを継続的に回すため、バグの混入が少なくなり、工程が進んだ後の手戻りのリスクの削減や品質の維持につながります



=== CIで利用できるツールって何があるの？
先ほど説明したようなビルドを自動で実行するためのツールはいくつかありますが、ここではJenkins、CircleCI、TravisCIの3つの +
CIツールについて簡単に説明したいと思います。

image:reveal.js/images/compare_citools.png[]

この3つのCIツールを構築の面で見たときに、Jenkinsはオンプレミスなため利用するには、自らで構築を行う必要がありますが自ら構築 +
する分自由度は高いです。CircleCiとTravisCiに関してはSaasであり、自らで構築する必要がないためサービスに登録すればすぐに +
利用することができますが、自由度は低くなります。
次に、GitHubと連携ができるかを見た時に、3つのツールともGithubと連携することが可能です。 +
次に、WebUIで設定ができるかを見たたときに、JenkinsとCircleCIはWebUIで簡単に設定することが可能ですが、TravisCiに関しては、 +
yaml定義ファイルによって設定を行う必要があるため、設定したい内容をいファイルで書けるということが利用の条件になります。

情報を公開することに問題がないOSSや個人的な開発を行う上では、GitHubでバージョン管理し、circleciやTravis CIを利用し +
ビルドを行うことに問題はありません。しかし、情報を内部に閉じたい開発では、GitHubやcircleci、Travis CIといったSaaSは +
情報漏洩のリスクやセキュリティを自ら設定できないという点で利用しづらいです。そのため、情報を内部で閉じたい開発の場合は、 +
バージョン管理システムにはオンプレミスで構築可能なGitLabやGitBucketを利用しCIツールにはJenkinsを利用するといった形を +
取ることがあります。


=== Jenkins
JenkinsとはCIで説明したビルドを自動で行うためのツールである。

==== Jenkinの起動方法
ここでは、Jenkinsを利用するための前準備は完了している前提で起動方法について説明を行います。

jenkinsのホームページからjenkins.warをダウンロードします。java -jar jenkins.warで起動可能です。 +
あとは、http://localhost:8080にアクセスすればJenkinsを利用することができます。

また、tomcatのwebappsディレクトリにjenkins.warを配置し、tomcatを起動することでもJenkinsを利用することが可能です。

docker

==== Jenkinsのメリットって？
Jenkinsを利用するメリットはいくつかあります。 +

** 集合知がある +
Jenkinsには多くのプラグインが存在し、用途によって使用するプラグインを選択し自由にカスタマイズできるため汎用性が高いです。 +
また、書籍も出版されておりネットにも多くの情報が転がっているため、設定方法やエラー事象の解決方法を発見できる可能性が高いです。

** GUIで設定可能 +
Jenkinsのタスクを実行するための設定(ジョブ)はGUIベースで行うことができ、誰でも簡単に設定することができます。 +
項目についての説明は省かせていただきますが、基本的には、設定したいものにチェックを入れ、チェックを入れると出てくる項目に +
設定内容を追加することで処理が適応されます。　+
image:reveal.js/images/settings1.png[]
image:reveal.js/images/settings2.png[]

** 定期実行可能 +
JenkinsはCronによってビルドの実行時間を設定することができます。これにより、毎日定期的に行うビルドに関しては、人の手で +
行う必要がなくなるため、ビルド忘れの防止や稼働時間の削減につながります。
image:reveal.js/images/execute_time.png[]

** WebHookの設定が可能 +
WebHookとは、簡単に説明するとAというアプリとBというアプリがあったときに、Aのアプリでイベントが発生したときに、Bのアプリに +
イベントが発生したことをリアルタイムで通知するようなことを言います。
image:reveal.js/images/webhook.png[]

Jenkinsは、このWebHookの仕組みを利用することで、バージョン管理システムに対して変更が適応される度に、自動でビルドを実行
することが可能になります。

=== Git使ってますか？

先ほどGitについて少し話をしたので、急ではありますがここでGitについて説明したいと思います。 +
皆さん、そもそもGit利用していますか？ +
まだ、バージョン管理システムにSVNを利用していませんか？バージョン管理システムと言えば今はGitです。 +
image:reveal.js/images/statics.png[]

参考資料：https://blogs.oracle.com/ouchina/2016java

ZeroTurnaround社が2016年に公表した資料の中のバージョン管理システムの利用率を示したグラフをご覧ください。 +
2016年時点のGitの利用率は68%と全体の3分の2を占めており、バージョン管理システムにSVNではなくGitが広く +
使われていることが分かると思います。　+

なぜ、ソースコード管理システムにGitが多く使われているのでしょうか？ +

SVNが　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　




image:reveal.js/images/git-flow.png[]



image:reveal.js/images/github-flow.png[]



開発者が作業する場所がtrunkしかないうえに、リポジトリが一つであり、変更を容易にコミットすることが +
できなかった。また、レビューをする際には管理簿のようなものを用意する必要があった。 +
Gitは、masterとブランチから構成されており、開発者はmasterからブランチを複数切ることができ、ブランチごとに作業を分けることが可能となりました。また、リモートと +
ローカルにリポジトリを持っており、変更をSVNとはことなり容易にコミットできるようになりました。
最も大きな点としてはソースコード差分を見ることができ、それに対してレビューが行えるため、Gitだけで変更の管理を行えるようになりました。

=== Jenkins2

ここまでに説明したメリットはJenkins1の情報であり、ご存知の方も多いのではないでしょうか？ +
Jenkins2では、大きく変わった点があります。

** Jenkinsfileが追加された
pipeline機能がJenkins1では、プラグインを利用する必要があったが、Jenknis2からは公式サポートされたことにより +
Jenkinsfileが追加された。


Gitとの相性が良くなったというのはgitの機能に関連します。

multibranchPipelineではブランチごとにジョブが実行され、Pipelineでは指定したブランチのみジョブが実行されます。 +

** ジョブの定義をファイルで行うことが可能となった +
Jenkins1を利用したことがある人はブランチがたくさんできるからその度にジョブを定義しなくてはいけないのではと思ったのではないでしょうか？ +
これを解決するのがJenkins2から導入されたJenkinsfileです。 +
Jenkinsfileはgroovyで書けるジョブを定義したファイルです。 +
このJenkinsfileをmasterに持たせておけば、ブランチを切る度にそのブランチにはJenkinsfileが存在するため、 +
わざわざブランチごとにジョブを作成する必要がなくなります。 +
また、ファイルでジョブ設定を管理できることになったことによって、バックアップをGUIで設定を変更の度に取らなくても良くなり、 +
バックアップができていなかった時にも、柔軟に対応することが可能となります。 +
また、ファイル管理できることで、複数の人が設定を変更することが可能になり、またgitで管理をしているためコードの差分に対してレビューができるようになります。 +
デメリットとしては、ファイルを書けないと設定ができないため属人性が生まれてしまう可能性があるということです。 +


